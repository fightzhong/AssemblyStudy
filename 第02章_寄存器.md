### 内存寻址
```
内存寻址: 基础地址 + 偏移地址 = 物理地址, 在8086cpu中, 基础地址为段地址*16, 利用基础地址和相对于基础地址的偏移地址
进行相加, 给出内存单元的物理地址, 即段地址 * 16 + 偏移地址 = 物理地址

内存并没有分段, 段的划分来自于CPU, 由于8086CPU用“基础地址(段地址*16)+偏移地址=物理地址”的方式给出内存单元的物理地址,
使得我们可以用分段的方式来管理内存
```

### win10安装debug程序
```
1、下载DOSBox, 官网下载即可, 下载完后直接安装
2、下载debug.exe文件, 百度即可下载到, 放入c:\mydebug文件夹, 也可以是任意文件夹中
3、启动DOSBox, 会弹出两个窗口, 在非cmd窗口中执行命令: mount c c:\mydebug  将mydebug文件夹进行挂载, 这样进入c盘后才能直接启动debug命令
4、挂载完成后, 进入c盘[执行c:], 然后执行命令[debug]即可进入debug界面

下面是需要将debug挂载永久生效, 不然每次打开DOSBox都要进行挂载:
    开始菜单 -> DOSBox文件夹 -> 打开DOSBox-0.74.3 Options  类似这样的文件, 会弹出一个dosbox-0.74-3.conf文件
    然后拉到文件最下面有一个[autoexec]栏目, 在这下面加入三行:
        mount c c:\mydebug
        c:
        debug
    这样每次启动DOSBox, 就自动进入debug了

    还可以在debug的安装目录找到DOSBox 0.74-3 Options.bat文件双击执行也可以打开config文件

更加详细的可以打开DOSBox安装目录下的Documentation文件夹中的README文件, 查看跟Options相关的描述
```

### debug命令
```
Debug时DOS、Windows都提供的实模式程序的调试工具, 可以利用它查看CPU各种寄存器中的内容、内存的情况和在机器码级别跟踪程序的运行

R: 查看、改变CPU寄存器的内容
D: 查看内存中的内容
E: 改写内存中的内容
U: 将内存中的机器指令翻译成汇编指令
T: 执行一条机器指令
A: 以汇编指令的格式在内存中写入一条机器指令
P: 用该命令执行int 21H, 用于正常退出程序

<1> 查看CPU寄存器的内容, 同时下方显示CS:IP中对应的指令机器码以及翻译成汇编后的指令: r
<2> 更改AX寄存器的内容为1111, 先执行指令r ax, 然后会输出当前AX寄存器的内容, 我们可以输入新的值并且按回车完成修改
<3> D命令查看内存中的数据, 查看指定内存中的数据: d 段地址:偏移地址, 查看指定范围内存中的数据: d 段地址:开始偏移地址 结束偏移地址
<4> 用e命令改写内存范围中的数据: e 段地址:偏移地址 数据1 数据2 数据3 数据4 数据5
        ---- 表示改变从偏移地址开始后5个内存单元的内容
    用e命令改写指定内存中的数据: e 段地址:偏移地址 数据
        ---- 表示改变偏移地址对应的内存单元中的内容
    用e命令改写指定内存中的数据: e 段地址:偏移地址
        ---- 这个时候会出现一个小数点, 表示准备接收数据, 我们可以输入数据, 然后按空格进入下一个内存单元的输入框, 如果当前内存单元不想要
             修改数据, 则直接按空格即可
    用e命令改写指定内存中的数据(字符): e 段地址:偏移地址 'a' 'b'
    用e命令改写指定内存中的数据(字符串): e 段地址:偏移地址 'hello, world'
    按Enter键完成修改操作

    用e命令写入机器码指令: 
            b80100 对应 mov ax 0001
            b90200 对应 mov cx 0002
            01c8   对应 add ax cx
        命令为: e 1000:0 b8 01 00 b9 02 00 01 c8
<5> 用u命令查看机器码指令对应的汇编指令, u 段地址:偏移地址, 比如: u 1000:0
    查出来的数据分为三个部分: 内存单元地址范围、机器码、汇编指令
<6> 用t命令执行cs:ip寄存器对应的内存单元指令
<7> 用a命令将汇编指令写入对应的内存单元: a 段地址:偏移地址, 比如:
        a 1000:0
        mov ax,ffff
```

### 修改cs:ip
```
cs: code segment

方式一: 直接利用debug命令中的r命令修改寄存器中的值
方式二: 执行汇编命令jmp(转移指令), 同时修改cs:ip即为 jmp 段地址:偏移地址, 仅仅修改偏移地址 jmp 偏移地址, 比如:
        jmp 1000:0
        jmp ff
方法三: 执行汇编命令jmp, 修改ip寄存器的值为其他寄存器的值, 比如jmp ax

8086CPU工作过程:
    1、从CS:IP指向的内存单元读取指令, 读取的指令进入指令缓冲器
    2、IP指向下一条指令
    3、执行指令
```

### 寄存器作用
```
AX、BX、CX、DX: 通用寄存器
BX: 一般结合DS寄存器进行内存访问, ds:[bx], 即一般用作偏移地址, 也可以用作通用寄存器
CX: 一般表示循环次数, loop指令会通过CX来判断是否继续执行, 当CX为0的时候不会执行循环
SS:SP: 前者是栈段寄存器, 后者是栈偏移地址寄存器, 两者构成一个栈的物理地址
CS:IP: 前者是代码段寄存器, 后者是代码偏移地址寄存器, 两者构成一行代码指令的物理地址
DS: 数据段寄存器, 利用DS和[数值]来获取数据所在的物理地址, 在debug中我们手动写入汇编指令mov ax, [0]
    表示将DS表示段地址, 0为偏移地址所在的字数据放入ax中, 但是对于masm来说, 会将[0]当成数据0, 而不是
    偏移地址, 这个时候我们需要借助通用寄存器bx
ES: 扩展段寄存器, 在ds不能满足内存段地址的情况下, 可以用es来代替ds, 比如es:[bx]
BP: 也可以用作偏移地址, ds:[bp], 如果不主动指明段寄存器为ds, 那么默认为ss作为段寄存器, 访问内存的即为ss:[bp]

SI和DI: 和BX的功能相近, 即可用于偏移地址, 比如下面几组例子功能一样:
            (1) mov bx, 0
                mov ax, [bx]
            (2) mov si, 0
                mov ax, [si]
            (3) mov di, 0
                mov ax, [di]
```

### 伪指令
```
db: defined byte 定义字节数据
dw: defined word 定义字型数据(两个字节)
dd: double word  定义双字型数据(四个字节)
    例子:
        db '1977'
        dw 100
        dd 100001

dup: 用于定义数据的重复, 与db、dw、dd等数据定义伪指令配合使用
    db 3 dup (0): 定义了3个字节, 它们的值都是0, 相当于db 0, 0, 0
    db 3 dup (0,1,2): 定义了3个字节, 它们是0, 1, 2, 0, 1, 2, 0, 1, 2, 相当于db 0, 1, 2, 0, 1, 2, 0, 1, 2
```