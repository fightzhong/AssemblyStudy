### 内存中字的存储
```
CPU中, 用16位寄存器来存储一个字, 高8位存放高位字节, 低8位存放低位字节, 在内存中存储时, 由于内存单元是字节单元(一个单元存放一个字节),
则一个字要用两个连续地址的内存单元来存放, 这个字的低位字节存放在低地址单元中, 高位字节存放在高地址单元中, 比如4E20的存放就是如下:
20
4E

8086CPU不支持直接将数据送入段寄存器, 数据都不能直接和段地址交互, 即段地址不能直接赋值
```

### DS和[address]
```
DS: 数据段寄存器, [address]表示数据的偏移地址, DS: 1000H, [0020H] 则表示段地址为1000H, 偏移地址为20H

8086CPU不支持直接将数据送入段寄存器, 比如mov DS, 1000, 对于这种情况, 我们需要利用一个通用寄存器来进行中转, 比如
将al中的数据送入内存单元为10000H中:
    mov bx, 1000
    mov ds, bx
    mov [0], al

mov指令有以下几种形式:
    mov 寄存器,数据
    mov 寄存器,寄存器
    mov 寄存器,内存单元
    mov 内存单元,寄存器
    mov 段寄存器,寄存器
    mov 寄存器,段寄存器
    mov 段寄存器,内存单元
    mov 内存单元,段寄存器
```

### 栈
```
push 寄存器(也可以是段寄存器): 将一个寄存器中的数据入栈
pop 寄存器(也可以是段寄存器): 出栈, 用一个寄存器接收出栈的数据

push 内存单元: 将一个内存字单元处的字入栈(注意: 栈操作都是以字作为单位)
pop 内存单元: 出栈, 用一个内存字单元接收出栈的数据

SS、SP分别表示栈顶的段地址和偏移地址

push指令的执行步骤:
    1、SP = SP - 2
    2、向SS:SP指向的字单元中传入数据

pop指令的执行步骤:
    1、 从SS:SP指向的字单元中读取数据
    2、 SP = SP + 2

例子:
pop ax
    1. 将SS:SP指向的内存单元处的数据送入ax中
    2. SP=SP+2, SS:SP指向当前栈顶下面的单元, 以当前栈顶下面的单元为新的栈顶

pop、push指令能够实现内存单元中的数据和寄存器中的数据交换, 栈空间其实就是内存中的, 栈操作都是基于字作为单位的:
    pop ds: 将栈顶的数据放到ds寄存器中
    push [0]: 将ds段寄存器指向的段地址, [0]指向的偏移地址中的内存单元数据放入栈中

任意时刻, SS:SP指向栈顶元素, 8086CPU只记录栈顶, 栈空间的大小我们要自己管理
```