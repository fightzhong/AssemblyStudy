### 标志寄存器
```
15 13 13 12 11(OF) 10(DF) 9(IF) 8(TF) 7(SF) 6(ZF) 5 4(AF) 3 2(PF) 1 0(CF)

在8086CPU的指令集中, add、sub、mul、div、inc、or、and指令等大多数运算指令是影响标志寄存器的,

```

### ZF标志位
```
零标志位, 它记录相关指令执行后, 其结果是否为0, 如果为0, 那么ZF = 1, 如果不为0, 那么ZF = 0
```

### PF标志位
```
奇偶标志位, 记录相关指令执行后, 其结果的所有bit位中1的个数是否为偶数, 如果1的个数为偶数, pf = 1, 如果为奇数, 则pf = 0
```

### SF标志位
```
符号标志位, 记录相关指令执行后,其结果是否为负数, 如果为负数, 则sf = 1, 如果为非负数, sf = 0

CPU对有符号数运算结果的一种记录, 记录数据的正负, 在我们将数据当作有符号数来运算的时候, 可以通过它来得知结果的正负, 如果我们将数据
当成无符号数来运算, SF的值则没有意义, 虽然相关的指令影响了它的值

CPU在执行add等指令的时候, 必然会影响到SF标志位的值
```

### CF标志位
```
进位标志位, 一般情况下, 在进行**无符号数**运算的时候, 它记录了运算结果的最高有效位向更高位的进位值(加法), 或从更高位的借位值(减法)

例子1:   
    mov al, 98h
    add al, al      ; 执行后, al = 30h, cf = 1, cf记录了从最高有效位向更高位的进位值
    add al, al      ; 执行后, al = 60h, cf = 0, cf记录了从最高有效位向更高位的进位值

例子2:
    mov al, 97h
    sub al, 98h     ; 执行后, al = FFh, cf = 1, cf记录了向更高位的借位值
    sub al, al      ; 执行后, al = 0, cf = 0, cf记录了向更高位的借位值
```

### OF标志位
```
溢出: 在进行有符号数运算的时候, 如结果超过了机器所能表示的范围称为溢出 (溢出只针对有符号数运算)

机器所表示的范围: 指令运算的结果用8位寄存器或内存单元来存放, 比如add al, 3, 那么对于8位的有符号数据, 机器所能表示的范围就是-128~127, 16位即为-32768~32767

例子:
    mov al, 98
    add al, 99

    执行后将产生溢出, 因为al = 98 + 99 = 197, 溢出后结果为0xC5, 因为是有符号运算, 所以al存储的是有符号数, c5H是有符号数-59的补码, 实际结果是197, 但是显示
    为C5h

OF标志位: 溢出标志位, 记录了有符号数运算的结果是否发生了溢出, 如果发生溢出, 则OF = 1, 如果没有溢出, 则OF = 0, 所以我们在计算OF的值的时候, 要将一个数当成有符号数来处理
```

### adc指令
```
adc指令: 带进位加法指令, 利用了CF位上记录的进位值 / 借位值
格式: adc 操作对象1, 操作对象2
功能: 操作对象1 = 操作对象1 + 操作对象2 + CF

比如: adc ax, bx  实现的功能为 ax = ax + bx + cf
```

### sbb指令
```
sbb指令: 带借位减法质量, 利用了CF位上记录的借位值
指令格式: sbb 操作对象1, 操作对象2
功能: 操作对象1 = 操作对象1 - 操作对象2 - CF

比如: sbb ax, bx  实现的功能为 ax = ax - bx - cf
```

### cmp指令和条件转移指令
```
cmp指令: 比较指令, 功能相当于减法指令, 只是不保存结果, 执行后, 会对标志寄存器产生影响, 然后利用相关指令来识别这些被影响的标志寄存器来得知比较结果
格式: cmp 操作对象1, 操作对象2
功能: 操作对象1 - 操作对象2, 不保存结果, 改变标志寄存器的值


je: 等于则转移, 检测的标志位: zf = 1
jne: 不等于则转移, 检测的标志位: zf = 0
jb: 低于则转移, 检测的标志位: cf = 1
jnb: 不低于则转移, 检测的标志位: cf = 0
ja: 高于则转移, 检测的标志位: cf = 0 且 zf = 0
jna: 不高于则转移, 检测的标志位: cf = 1 或 zf = 1

编程例子:
    统计data段中数值为8的字节的个数, 用ax保存统计结果
    data segment
        db 8, 11, 8, 1, 8, 5, 63, 38
    data ends

    mov ax, data
    mov ds, ax
    mov bx, 0   ; ds:bx指向第一个字节
    mov ax, 0   ; 初始化累加器
    mov cx, 8
s:  cmp byte ptr [bx], 8    ; 和8进行比较
    jne next                ; 如果不相等则转到next, 继续循环
    inc ax                  ; 如果相等就将计数值加1
next:   inc bx
        loop s
```

### DF标志和串传送指令
```
DF: 方向标志位, 在串处理指令中, 控制每次操作后si、di的增减

df = 0, 每次操作后si、di递增
df = 1, 每次操作后si、di递减

movsb指令: 串传送指令
功能: movsb的功能是将ds:si指向的内存单元中的字节送入es:di中, 然后根据标志寄存器df位的值, 将si和di递增或者递减, 指向movsb指令相当于进行下面几步
        (1) es * 16 + di = ds * 16 + si
        (2) 如果df = 0则:
                    si = si + 1
                    di = di + 1
            如果df = 1则:
                    si = si - 1
                    di = di - 1
用汇编语法描述:
    mov es:[di], byte ptr ds:[si]
    如果df = 0:
        inc si
        inc di
    如果df = 1:
        des si
        des di


movsw指令功能: movsb的功能是将ds:si指向的内存单元中的字送入es:di中, 然后根据标志寄存器df位的值, 将si和di递增2或者递减2
rep指令: 配合movsb或者movsw指令一起使用, 根据cx的值, 重复执行串传送指令, 循环cx次

rep movsb相当于: 
    s:  movsb
        loop s


cld指令: 将标志寄存器中的df设置为0
std指令: 将标志寄存器中的df设置为1
```

### pushf和popf
```
pushf: 将标志寄存器的值压栈
popf: 从栈中弹出数据, 送入标志寄存器中

这两个指令为直接访问标志寄存器提供了方法
```

### 标志寄存器在Debug中的表示
```
                    NV      UP      EI      PL      NZ      NA      PO      NC
表示的标志寄存器       OF      DF              SF      ZF              PF     CF


标志                值为1的标记                 值为0的标记
OF                  OV                          NV                 
SF                  NG                          PL                 
ZF                  ZR                          NZ
PF                  PE                          PO
CF                  CY                          NC
DF                  DN                          UP
```
