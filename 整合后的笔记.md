## 第02章_寄存器
### 内存寻址
```
内存寻址: 基础地址 + 偏移地址 = 物理地址, 在8086cpu中, 基础地址为段地址*16, 利用基础地址和相对于基础地址的偏移地址
进行相加, 给出内存单元的物理地址, 即段地址 * 16 + 偏移地址 = 物理地址

内存并没有分段, 段的划分来自于CPU, 由于8086CPU用“基础地址(段地址*16)+偏移地址=物理地址”的方式给出内存单元的物理地址,
使得我们可以用分段的方式来管理内存
```

### win10安装debug程序
```
1、下载DOSBox, 官网下载即可, 下载完后直接安装
2、下载debug.exe文件, 百度即可下载到, 放入c:\mydebug文件夹, 也可以是任意文件夹中
3、启动DOSBox, 会弹出两个窗口, 在非cmd窗口中执行命令: mount c c:\mydebug  将mydebug文件夹进行挂载, 这样进入c盘后才能直接启动debug命令
4、挂载完成后, 进入c盘[执行c:], 然后执行命令[debug]即可进入debug界面

下面是需要将debug挂载永久生效, 不然每次打开DOSBox都要进行挂载:
    开始菜单 -> DOSBox文件夹 -> 打开DOSBox-0.74.3 Options  类似这样的文件, 会弹出一个dosbox-0.74-3.conf文件
    然后拉到文件最下面有一个[autoexec]栏目, 在这下面加入三行:
        mount c c:\mydebug
        c:
        debug
    这样每次启动DOSBox, 就自动进入debug了

    还可以在debug的安装目录找到DOSBox 0.74-3 Options.bat文件双击执行也可以打开config文件

更加详细的可以打开DOSBox安装目录下的Documentation文件夹中的README文件, 查看跟Options相关的描述
```

### debug命令
```
Debug时DOS、Windows都提供的实模式程序的调试工具, 可以利用它查看CPU各种寄存器中的内容、内存的情况和在机器码级别跟踪程序的运行

R: 查看、改变CPU寄存器的内容
D: 查看内存中的内容
E: 改写内存中的内容
U: 将内存中的机器指令翻译成汇编指令
T: 执行一条机器指令
A: 以汇编指令的格式在内存中写入一条机器指令
P: 用该命令执行int 21H, 用于正常退出程序

<1> 查看CPU寄存器的内容, 同时下方显示CS:IP中对应的指令机器码以及翻译成汇编后的指令: r
<2> 更改AX寄存器的内容为1111, 先执行指令r ax, 然后会输出当前AX寄存器的内容, 我们可以输入新的值并且按回车完成修改
<3> D命令查看内存中的数据, 查看指定内存中的数据: d 段地址:偏移地址, 查看指定范围内存中的数据: d 段地址:开始偏移地址 结束偏移地址
<4> 用e命令改写内存范围中的数据: e 段地址:偏移地址 数据1 数据2 数据3 数据4 数据5
        ---- 表示改变从偏移地址开始后5个内存单元的内容
    用e命令改写指定内存中的数据: e 段地址:偏移地址 数据
        ---- 表示改变偏移地址对应的内存单元中的内容
    用e命令改写指定内存中的数据: e 段地址:偏移地址
        ---- 这个时候会出现一个小数点, 表示准备接收数据, 我们可以输入数据, 然后按空格进入下一个内存单元的输入框, 如果当前内存单元不想要
             修改数据, 则直接按空格即可
    用e命令改写指定内存中的数据(字符): e 段地址:偏移地址 'a' 'b'
    用e命令改写指定内存中的数据(字符串): e 段地址:偏移地址 'hello, world'
    按Enter键完成修改操作

    用e命令写入机器码指令: 
            b80100 对应 mov ax 0001
            b90200 对应 mov cx 0002
            01c8   对应 add ax cx
        命令为: e 1000:0 b8 01 00 b9 02 00 01 c8
<5> 用u命令查看机器码指令对应的汇编指令, u 段地址:偏移地址, 比如: u 1000:0
    查出来的数据分为三个部分: 内存单元地址范围、机器码、汇编指令
<6> 用t命令执行cs:ip寄存器对应的内存单元指令
<7> 用a命令将汇编指令写入对应的内存单元: a 段地址:偏移地址, 比如:
        a 1000:0
        mov ax,ffff
```

### 修改cs:ip
```
cs: code segment

方式一: 直接利用debug命令中的r命令修改寄存器中的值
方式二: 执行汇编命令jmp(转移指令), 同时修改cs:ip即为 jmp 段地址:偏移地址, 仅仅修改偏移地址 jmp 偏移地址, 比如:
        jmp 1000:0
        jmp ff
方法三: 执行汇编命令jmp, 修改ip寄存器的值为其他寄存器的值, 比如jmp ax

8086CPU工作过程:
    1、从CS:IP指向的内存单元读取指令, 读取的指令进入指令缓冲器
    2、IP指向下一条指令
    3、执行指令
```

### 寄存器作用
```
AX、BX、CX、DX: 通用寄存器
BX: 一般结合DS寄存器进行内存访问, ds:[bx], 即一般用作偏移地址, 也可以用作通用寄存器
CX: 一般表示循环次数, loop指令会通过CX来判断是否继续执行, 当CX为0的时候不会执行循环
SS:SP: 前者是栈段寄存器, 后者是栈偏移地址寄存器, 两者构成一个栈的物理地址
CS:IP: 前者是代码段寄存器, 后者是代码偏移地址寄存器, 两者构成一行代码指令的物理地址
DS: 数据段寄存器, 利用DS和[数值]来获取数据所在的物理地址, 在debug中我们手动写入汇编指令mov ax, [0]
    表示将DS表示段地址, 0为偏移地址所在的字数据放入ax中, 但是对于masm来说, 会将[0]当成数据0, 而不是
    偏移地址, 这个时候我们需要借助通用寄存器bx
ES: 扩展段寄存器, 在ds不能满足内存段地址的情况下, 可以用es来代替ds, 比如es:[bx]
BP: 也可以用作偏移地址, ds:[bp], 如果不主动指明段寄存器为ds, 那么默认为ss作为段寄存器, 访问内存的即为ss:[bp]

SI和DI: 和BX的功能相近, 即可用于偏移地址, 比如下面几组例子功能一样:
            (1) mov bx, 0
                mov ax, [bx]
            (2) mov si, 0
                mov ax, [si]
            (3) mov di, 0
                mov ax, [di]
```

### 伪指令
```
db: defined byte 定义字节数据
dw: defined word 定义字型数据(两个字节)
dd: double word  定义双字型数据(四个字节)
    例子:
        db '1977'
        dw 100
        dd 100001

dup: 用于定义数据的重复, 与db、dw、dd等数据定义伪指令配合使用
    db 3 dup (0): 定义了3个字节, 它们的值都是0, 相当于db 0, 0, 0
    db 3 dup (0,1,2): 定义了3个字节, 它们是0, 1, 2, 0, 1, 2, 0, 1, 2, 相当于db 0, 1, 2, 0, 1, 2, 0, 1, 2
```

## 第03章_寄存器内存访问
### 内存中字的存储
```
CPU中, 用16位寄存器来存储一个字, 高8位存放高位字节, 低8位存放低位字节, 在内存中存储时, 由于内存单元是字节单元(一个单元存放一个字节),
则一个字要用两个连续地址的内存单元来存放, 这个字的低位字节存放在低地址单元中, 高位字节存放在高地址单元中, 比如4E20的存放就是如下:
20
4E

8086CPU不支持直接将数据送入段寄存器, 数据都不能直接和段地址交互, 即段地址不能直接赋值
```

### DS和[address]
```
DS: 数据段寄存器, [address]表示数据的偏移地址, DS: 1000H, [0020H] 则表示段地址为1000H, 偏移地址为20H

8086CPU不支持直接将数据送入段寄存器, 比如mov DS, 1000, 对于这种情况, 我们需要利用一个通用寄存器来进行中转, 比如
将al中的数据送入内存单元为10000H中:
    mov bx, 1000
    mov ds, bx
    mov [0], al

mov指令有以下几种形式:
    mov 寄存器,数据
    mov 寄存器,寄存器
    mov 寄存器,内存单元
    mov 内存单元,寄存器
    mov 段寄存器,寄存器
    mov 寄存器,段寄存器
    mov 段寄存器,内存单元
    mov 内存单元,段寄存器
```

### 栈
```
push 寄存器(也可以是段寄存器): 将一个寄存器中的数据入栈
pop 寄存器(也可以是段寄存器): 出栈, 用一个寄存器接收出栈的数据

push 内存单元: 将一个内存字单元处的字入栈(注意: 栈操作都是以字作为单位)
pop 内存单元: 出栈, 用一个内存字单元接收出栈的数据

SS、SP分别表示栈顶的段地址和偏移地址

push指令的执行步骤:
    1、SP = SP - 2
    2、向SS:SP指向的字单元中传入数据

pop指令的执行步骤:
    1、 从SS:SP指向的字单元中读取数据
    2、 SP = SP + 2

例子:
pop ax
    1. 将SS:SP指向的内存单元处的数据送入ax中
    2. SP=SP+2, SS:SP指向当前栈顶下面的单元, 以当前栈顶下面的单元为新的栈顶

pop、push指令能够实现内存单元中的数据和寄存器中的数据交换, 栈空间其实就是内存中的, 栈操作都是基于字作为单位的:
    pop ds: 将栈顶的数据放到ds寄存器中
    push [0]: 将ds段寄存器指向的段地址, [0]指向的偏移地址中的内存单元数据放入栈中

任意时刻, SS:SP指向栈顶元素, 8086CPU只记录栈顶, 栈空间的大小我们要自己管理
```

## 第04章_第一个程序
### 编写一个汇编程序
```
创建1.asm汇编文件, 在文件中输入以下代码

assume cs:codeseg

codeseg segment
start:	
	mov ax, 2
	add ax,ax
	add ax,ax
	mov ax,4c00h
	int 21h
codeseg ends
end start


assume: 将寄存器与程序中的某一个用segment...ends定义的段相关联
xxx segment: 表示段的开始
xxx ends: 表示段的结束

start: 表示程序入口
end start: 表示程序结束

mov ax,4c00h
int 21h: 这两行用于返回程序, int 21h表示触发16进制表示的21中断

注意: 在汇编的源程序中, 数据不能以字母开头, 即不能出现 mov ax, ffffh这样的指令, 可以通过mov ax, 0ffffh来兼容
```

### 编译、连接、执行
```
编译: 1.asm中的是汇编代码, 需要将其转为机器代码, 这就是编译, 利用masm.exe完成编译功能
连接: 如果汇编代码中依赖了其他的库, 需要将这些库与程序关联起来, 得到一个可执行文件信息, 利用link.exe完成连接的功能
经过编译得到目标文件1.obj, 经过连接得到1.exe可执行文件

编译: masm 1.asm   或者 masm 1.asm;
连接: link 1.obj   或者 link 1.obj;
得到可执行文件1.exe

也可以利用ml.exe一步到位, 完成编译 + 连接: ml 1.asm, 编译连接操作需要放到win10命令行中

在win10中, 需要在dosbox执行1.exe, 不然会报不兼容的程序, 将masm.exe、link.exe、ml.exe放到dosbox挂载的盘中,
如果不想放到同一个盘, 可以在dosbox中增加一个挂载的盘, 这样dosbox就能访问对应的文件了

在命令行页面(win10为dosbox命令行), 执行1.exe, 命令行程序会将1.exe装载到内存, 然后将cs:ip设置为1.exe中的入口代码
所在的内存地址, 随后执行程序
```

### debug调试文件
```
1. 打开dosbox
2. 执行 debug 1.exe的全路径地址(如果不在同一个盘, 需要将其他盘挂载到dosbox中)
3. 利用debug命令执行
4. 利用p命令执行int 21h指令, 程序正常退出

利用debug运行exe文件后, cs:ip指向程序的第一行, ds和cs相隔10H个字节, 保存的是PSP信息, psp是dos系统用来跟
被加载程序进行通信的, 占用256个字节, 即10H

假设程序加载到内存后是存在于SA:0 这个地址, 那么真正的指令是从SA + 10H:0开始的
```

## 第05章_BX和loop指令
### bx和内存单元的描述
```
[bx]: 表示偏移地址为bx, 在asm代码中, mov ax, [0]会被当成mov ax, 0来看待, 而不是将段地址为ds,
      偏移地址为0的数据放到ax寄存器中, 换句话说, 编译器不会将[常量值]当成偏移地址, 对于这种情况,
      需要用到bx寄存器来代表偏移地址, 即mov ax, [bx], 当然, 如果直接在debug中输入指令mov ax, [0]
      确是可以将偏移地址为0的数据送入到ax寄存器中

汇编代码将内存单元为10H的数据放入到ax寄存器的方式:
    方式一: 
        mov bx, 10H 
        mov ax, [bx]
    方式二:
        mov bx, 10H 
        mov ax, ds:[bx]
    方式三:
        mov ax, ds:[10H]

注意: 通过ds:[bx]是能访问对应内存地址下的内容的, 但是ds:[ax]则不行, 中括号中的值只能是bx寄存器或者常量值, 不能
是其他寄存器的值, 否则会报编译错误
```

### loop指令的作用及执行流程
```
loop指令用于循环执行指令, loop <标号>表示循环执行标号开始的代码, cx中的值表示循环的次数, 比如

assume cs:codes
codes segment
start:
	mov bx, 0
    mov cx, 6h
s:	add ax, bx
	inc bx
	loop s

	mov ax, 4c00h
	int 21h
codes ends 
end start

上面的汇编代码表示循环执行s标号下两行代码6次

loop指令的执行流程:
    <1> cx = cx - 1
    <2> 判断cx是否为0, 如果为0, 则不继续执行, 如果不为0, 则ip跳转到标号对应的代码地址
有点类似于do...while

直接执行循环完毕的两个方案: p命令来替换t命令执行循环命令  或者 g命令跳转到后面的代码地址, g 段地址:偏移地址
```

## 第06章_包含多个段的程序
### 包含多个段的程序
```
dw: defined word 定义字
db: defined byte 定义字节



assume cs:code, ds:data,ss:stack

data segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends

code segment
start:  mov ax,stack
        mov ss,ax
        mov sp,20h      ;设置栈顶ss:sp指向stack:20
        mov ax,data  
        mov ds,ax       ;ds指向data段
        mov bx,0        ;ds:bx指向data段中的第一个单元
        mov cx,8

s:      push [bx]
        add bx,2
        loop s          ;以上将data段中的0~15单元中的8歌字型数据依次入栈

        mov bx,0
        mov cx,8

s0:     pop [bx]
        add bx,2
        loop s0         ;以上依次出栈8个字型数据到data段的0~15单元中

        mov ax,4c00h
        int 21h
```

## 第07章_更灵活的定位内存地址的方法
### and 和 or指令
```
and 指令: 通过该指令可讲操作对象的相应位设为0, 其他位不变, 只有两者都为1的情况下才为1, 只要有一个位为0就是0
    例子: mov al, 01100011B
         and al, 00111011B
         结果:    00100011B

or 指令: 通过该指令可将操作对象的相应位设为1, 其他位不变, 只要有一个1则为1, 只有两者都为0的情况下才为0
    例子: mov al, 01100011B
          or al, 00111011B
         结果:    01111011B
```

### 二重循环用栈来保存cx的信息


## 第08章知_数据处理的两个基本问题
### bx、si、di、bp
```
(1) 在8086CPU中, 只有这4个寄存器可用在[...]中来进行内存单元的寻址, 比如:
    mov ax,[bx]
    mov ax, [bx + si]
    mov ax, [bx + di]
    mov ax, [bp]
    mov ax, [bx + si]
    mov ax, [bx + di]

    mov ax, [cx] ---> 错误
    mov ax, [ax] ---> 错误
    mov ax, [dx] ---> 错误

(2) 在[...]中, 这四个寄存器可以单个出现, 或者只能以四种组合出现:
        1. bx和si
        2. bx和di
        3. bp和si
        4. bp和di
    
    mov ax, [bx]
    mov ax, [si]
    mov ax, [di]
    mov ax, [bp]
    mov ax, [bx + si]
    mov ax, [bx + di]
    mov ax, [bp + si]
    mov ax, [bp + di]
    mov ax, [bx + si + idata]

    mov ax, [bx + bp] ---> 错误
    mov ax, [si + di] ---> 错误

(3) 只要在[...]中使用寄存器bp, 而指令中没有显性的给出段地址, 段地址就默认在ss中, 比如:
    mov ax, [bp]   ==== (ax) = ( ss * 16 + bp )
    mov ax, [bp + si + idata]   ==== (ax) = ( ss * 16 + bp + si +  idata )
```

### 机器指令处理的数据在什么地方
```
mov bx, [0]    在内存 ds:[0]单元
mov bx, ax     在CPU内部, ax寄存器
mov bx, 0      在CPU内部, 指令缓存器
```

### 指令处理的数据有多长
```
(1) 通过寄存器名指明要处理的数据的尺寸
    mov ax, ds:[0]
    mov al, ds:[0]
(2) 在没有寄存器名存在的情况下, 用操作符X ptr指明内存单元的长度, X在汇编指令中可以为word或byte
    mov word ptr ds:[0],1
    inc word ptr [bx]

    mov byte ptr ds:[0], 1
    inc byte ptr [bx]
(3) 其他方法, 有些指令默认了访问的是字单元还是字节单元, 比如push指令默认为字操作
```

### div指令(除法)
```
(1) 除数: 有8位和16位两种, 在一个寄存器或内存单元中
(2) 被除数: 默认放在AX或DX + AX中, 如果除数为8位, 被除数则为16位, 默认在AX中存放; 
           如果除数为16位, 被除数则为32位, 在DX和AX中存放, DX存放高16位, AX存放低16位
(3) 结果: 如果除数为8位, 则AL存储除法操作的商, AH存储除法操作的余数;
         如果除数为16位, 则AX存储除法操作的商, DX存储除法操作的余数
 
 语法: div 寄存器
      div 内存单元

例子:
    div byte ptr ds:[bx]
        al = ax / (ds * 16 + bx) 的商
        ah = ax / (ds * 16 + bx) 的余数
    
    div word ptr es:[bx]
        ax = (dx * 10000h + ax) / (es * 16 + bx)的商
        ax = (dx * 10000h + ax) / (es * 16 + bx)的余数
```

## 第09章_转移指令的原理
### 整体总结
```
转移行为:
    (1) 只修改IP, 称为段内转移, 比如jmp ax
    (2) 同时修改CS和IP时, 称为段间转移, 比如 jmp 1000:0  (这个如果通过汇编代码这样写会报错, 如果在debug中写入这个代码则不会)

转移指令对IP的修改范围不同, 段内转移又分为: 短转移和近转移
    短转移IP的修改范围为-128 ~ 127
    近转移IP的修改范围为-32768 ~ 32767

转移指令分为以下几类:
    - 无条件转移指令(如: jmp)
    - 条件转移指令(如 jcxz)
    - 循环制冷(如果: loop)
    - 过程
    - 中断
```

### 汇编标号offset的作用
```
如果标号在当前段内: offset获取的是标号在段内的偏移地址, 这个时候有没有offset都是一样的
如果标号对应的是段地址: offset表示段的大小

assume cs:code

data segment
	db 'welcome to masm!'
	db 2h, 24h, 1h
data ends

code segment
start:	
s:	mov ax, 1
	mov ax, 2
	mov ax, 3
	mov bx, offset data ;data段的大小, 这里是0013H
	mov bx, offset s    ;s标号在code段的偏移地址, 这里是0

	mov ax, 4c00h
	int 21h
code ends
end start
```

### jmp指令描述
```
jmp指令要提供两种信息
    (1) 转移的目的地址
    (2) 转移的距离(段间转移、段内短转移、段内近转移)

jmp short 标号: 段内短转移, 转到标号处执行指令, 对IP的修改范围为-128~127, 如果超过这个值编译会报错 
                (标号处的地址 - jmp指令后的第一个字节的地址)需要是8位位移, 补码表示
jmp near ptr 标号: 段内近转移, 转到标号处执行指令, 对IP的修改范围为-32768~32767, 如果超过这个值编译会报错
                (标号处的地址 - jmp指令后的第一个字节的地址)需要是16位位移, 补码表示
jmp far ptr 标号: 段间转移, 远转移, 用标号的段地址和偏移地址修改CS和IP

jmp 16位寄存器: 段内偏移, 修改IP为寄存器的值

jmp word ptr 内存单元地址(段内偏移, 因为word是16个字节)
    mov ax, 0123h
    mov ds:[0], ax
    jmp word ptr ds:[0] ---> IP变为0123H

jmp dword ptr 内存单元地址(段间转移, 因为dword是两个字, 超过了16个字节, 高地址处为目的段地址, 低地址处为目的偏移地址)
    mov ax, 0123h
    mov ds:[0], ax
    mov word ptr ds:[2], 0
    jmp dword ptr ds:[0] ---> CS变0, IP变为0123
```

### jmp指令原理
```
assume cs:code

code segment
start:	
s:	mov ax, 0
    jmp short s
    add ax, 1
s:  inc ax


	mov ax, 4c00h
	int 21h
code ends
end start

上述指令的机器码表示形式为:
    0BBD:0000   B80000  MOV AX,0000
    0BBD:0003   EB03    JMP 0008
    0BBD:0005   ADD     AX,0001
    0BBD:0008   40      INC AX

最左边一列尾内存地址, 中间一列为机器码表示的汇编指令, 最右边一列为汇编指令, 对于JMP指令来说, 汇编指令已经将其表示
为跳转到内存地址为0008位置, 但是表现为机器码的时候却是EB03, EB表示是的JMP指令, 03表示的是偏移地址, 原因是当将
JMP指令加载到指令缓冲器后, IP转向下一条指令地址, 即ADD AX, 0001   执行JMP指令的时候, 根据此时IP和目标地址进行计算,
得到偏移地址为0008 - 0005 = 03, 所以表示为EB03 ------ 以上是段内偏移(短偏移 + 近偏移)的原理

对于段间偏移来说, 则EA(不是EB)后面跟着的是段地址和偏移地址
```

### jcxz命令
```
jcxz: 有条件转移指令, 所有的有条件转移指令都是短转移, IP的修改范围都是-128~127
指令格式:  jcxz 标号
执行流程
    (1) 当cx = 0时, IP = IP + 8位位移, 即当cx等于0的时候, 跳转到标号所在的地址, 标号与该命令的地址范围不能超过限定值
    (2) 位移计算: 8位位移 = 标号处的地址 - jcxz指令后的第一个字节的地址
    (3) 位移由编译程序在编译时算出
    (4) 当cx 不为0 的时候, 什么也不做, 执行下一条命令

相当于:
    if (cx == 0) {
        jmp short 标号
    }
```

### loop命令
```
loop: 循环指令, 所有的有条件转移指令都是短转移, IP的修改范围都是-128~127
指令格式: loop 标号    
执行流程:
    (1) cx = cx - 1
    (2) 如果cx 不为0, 则跳转到标号所在地址(8位位移)
    (3) 如果cx 为0, 则什么也不做, 继续向下执行

相当于:
    cx = cx - 1;
    if ( cx != 0 ) {
        jmp short 标号
    }
```

## 第10章_CALL和RET指令
### 指令解析
```
ret指令: 用栈中的数据, 修改IP的内容, 从而实现近转移 (弹出两个字节来替换IP的值, 等于一次pop操作, 因为栈是基于字操作的)
retf指令: 用栈中的数据, 修改CS和IP的内容, 从而实现远转移

CPU执行ret指令时:
    (1) ip = ss * 16 + sp
    (2) sp = sp + 2
    -----相当于
        POP IP
    


CPU执行retf指令时:
    (1) ip = ss * 16 + sp
    (2) sp = sp + 2
    (3) cs = ss * 16 + sp
    (4) sp = sp + 2
    -----相当于
        POP IP
        POP CS

call指令: 
    (1) 将当前的IP或CS和IP压入栈中
    (2) 转移
```

### call指令的几种形式
```
形式一: call 标号     [将当前的IP压栈后, 转到标号处执行指令, 这是依据位移来进行转移, 即IP与标号之间的位移, 此时CS是没有发生改变的]
            (1) sp = sp - 2
            (2) ss * 16 + sp = ip
            (3) ip = ip + 16位位移

形式二: call far ptr 标号       [实现段间转移]
            (1) sp = sp - 2
            (2) ss * 16 + sp = cs
            (3) sp = sp - 2
            (4) sp * 16 + sp = ip
            (5) CS = 标号所在段的段地址
            (6) IP = 标号在段中的偏移地址

            -----相当于
                PUSH CS
                PUSH IP
                jmp far prt 标号

形式三: call 16位寄存器 
            (1) SP = SP - 2
            (2) SS * 16 + SP = IP
            (3) IP = 16位寄存器的值
            -----相当于
                 PUSH IP
                 jmp 16位寄存器

形式四: call word ptr 内存单元地址
            -----相当于
                PUSH IP
                jmp word ptr 内存单元地址

       call dword ptr 内存单元地址
            -----相当于
                PUSH CS
                PUSH IP
                jmp dword ptr 内存单元地址
```

### mul指令
```
(1) 两个相乘的数, 要么都是8位, 要么都是16位, 如果是8位, 一个默认放在AL中, 另一个默认放在8位寄存器或者内存单元中, 如果是
    16位, 一个默认放在AX中, 另一个放在16位寄存器或者内存单元中
(2) 结果: 如果是8位乘法, 结果默认在AX中, 如果是16位乘法, 结果高位存在DX中, 低位存在AX中
```


## 第11章_标志寄存器
### 标志寄存器
```
15 13 13 12 11(OF) 10(DF) 9(IF) 8(TF) 7(SF) 6(ZF) 5 4(AF) 3 2(PF) 1 0(CF)

在8086CPU的指令集中, add、sub、mul、div、inc、or、and指令等大多数运算指令是影响标志寄存器的,

```

### ZF标志位
```
零标志位, 它记录相关指令执行后, 其结果是否为0, 如果为0, 那么ZF = 1, 如果不为0, 那么ZF = 0
```

### PF标志位
```
奇偶标志位, 记录相关指令执行后, 其结果的所有bit位中1的个数是否为偶数, 如果1的个数为偶数, pf = 1, 如果为奇数, 则pf = 0
```

### SF标志位
```
符号标志位, 记录相关指令执行后,其结果是否为负数, 如果为负数, 则sf = 1, 如果为非负数, sf = 0

CPU对有符号数运算结果的一种记录, 记录数据的正负, 在我们将数据当作有符号数来运算的时候, 可以通过它来得知结果的正负, 如果我们将数据
当成无符号数来运算, SF的值则没有意义, 虽然相关的指令影响了它的值

CPU在执行add等指令的时候, 必然会影响到SF标志位的值
```

### CF标志位
```
进位标志位, 一般情况下, 在进行**无符号数**运算的时候, 它记录了运算结果的最高有效位向更高位的进位值(加法), 或从更高位的借位值(减法)

例子1:   
    mov al, 98h
    add al, al      ; 执行后, al = 30h, cf = 1, cf记录了从最高有效位向更高位的进位值
    add al, al      ; 执行后, al = 60h, cf = 0, cf记录了从最高有效位向更高位的进位值

例子2:
    mov al, 97h
    sub al, 98h     ; 执行后, al = FFh, cf = 1, cf记录了向更高位的借位值
    sub al, al      ; 执行后, al = 0, cf = 0, cf记录了向更高位的借位值
```

### OF标志位
```
溢出: 在进行有符号数运算的时候, 如结果超过了机器所能表示的范围称为溢出 (溢出只针对有符号数运算)

机器所表示的范围: 指令运算的结果用8位寄存器或内存单元来存放, 比如add al, 3, 那么对于8位的有符号数据, 机器所能表示的范围就是-128~127, 16位即为-32768~32767

例子:
    mov al, 98
    add al, 99

    执行后将产生溢出, 因为al = 98 + 99 = 197, 溢出后结果为0xC5, 因为是有符号运算, 所以al存储的是有符号数, c5H是有符号数-59的补码, 实际结果是197, 但是显示
    为C5h

OF标志位: 溢出标志位, 记录了有符号数运算的结果是否发生了溢出, 如果发生溢出, 则OF = 1, 如果没有溢出, 则OF = 0, 所以我们在计算OF的值的时候, 要将一个数当成有符号数来处理
```

### adc指令
```
adc指令: 带进位加法指令, 利用了CF位上记录的进位值 / 借位值
格式: adc 操作对象1, 操作对象2
功能: 操作对象1 = 操作对象1 + 操作对象2 + CF

比如: adc ax, bx  实现的功能为 ax = ax + bx + cf
```

### sbb指令
```
sbb指令: 带借位减法质量, 利用了CF位上记录的借位值
指令格式: sbb 操作对象1, 操作对象2
功能: 操作对象1 = 操作对象1 - 操作对象2 - CF

比如: sbb ax, bx  实现的功能为 ax = ax - bx - cf
```

### cmp指令和条件转移指令
```
cmp指令: 比较指令, 功能相当于减法指令, 只是不保存结果, 执行后, 会对标志寄存器产生影响, 然后利用相关指令来识别这些被影响的标志寄存器来得知比较结果
格式: cmp 操作对象1, 操作对象2
功能: 操作对象1 - 操作对象2, 不保存结果, 改变标志寄存器的值


je: 等于则转移, 检测的标志位: zf = 1
jne: 不等于则转移, 检测的标志位: zf = 0
jb: 低于则转移, 检测的标志位: cf = 1
jnb: 不低于则转移, 检测的标志位: cf = 0
ja: 高于则转移, 检测的标志位: cf = 0 且 zf = 0
jna: 不高于则转移, 检测的标志位: cf = 1 或 zf = 1

编程例子:
    统计data段中数值为8的字节的个数, 用ax保存统计结果
    data segment
        db 8, 11, 8, 1, 8, 5, 63, 38
    data ends

    mov ax, data
    mov ds, ax
    mov bx, 0   ; ds:bx指向第一个字节
    mov ax, 0   ; 初始化累加器
    mov cx, 8
s:  cmp byte ptr [bx], 8    ; 和8进行比较
    jne next                ; 如果不相等则转到next, 继续循环
    inc ax                  ; 如果相等就将计数值加1
next:   inc bx
        loop s
```

### DF标志和串传送指令
```
DF: 方向标志位, 在串处理指令中, 控制每次操作后si、di的增减

df = 0, 每次操作后si、di递增
df = 1, 每次操作后si、di递减

movsb指令: 串传送指令
功能: movsb的功能是将ds:si指向的内存单元中的字节送入es:di中, 然后根据标志寄存器df位的值, 将si和di递增或者递减, 指向movsb指令相当于进行下面几步
        (1) es * 16 + di = ds * 16 + si
        (2) 如果df = 0则:
                    si = si + 1
                    di = di + 1
            如果df = 1则:
                    si = si - 1
                    di = di - 1
用汇编语法描述:
    mov es:[di], byte ptr ds:[si]
    如果df = 0:
        inc si
        inc di
    如果df = 1:
        des si
        des di


movsw指令功能: movsb的功能是将ds:si指向的内存单元中的字送入es:di中, 然后根据标志寄存器df位的值, 将si和di递增2或者递减2
rep指令: 配合movsb或者movsw指令一起使用, 根据cx的值, 重复执行串传送指令, 循环cx次

rep movsb相当于: 
    s:  movsb
        loop s


cld指令: 将标志寄存器中的df设置为0
std指令: 将标志寄存器中的df设置为1
```

### pushf和popf
```
pushf: 将标志寄存器的值压栈
popf: 从栈中弹出数据, 送入标志寄存器中

这两个指令为直接访问标志寄存器提供了方法
```

### 标志寄存器在Debug中的表示
```
                    NV      UP      EI      PL      NZ      NA      PO      NC
表示的标志寄存器       OF      DF              SF      ZF              PF     CF


标志                值为1的标记                 值为0的标记
OF                  OV                          NV                 
SF                  NG                          PL                 
ZF                  ZR                          NZ
PF                  PE                          PO
CF                  CY                          NC
DF                  DN                          UP
```


## 第12章_内中断
### 中断描述
```
当CPU内部有下面的情况发生的时候, 将产生相应的中断信息:
    (1) 除法错误, 比如执行div指令产生的除法溢出
    (2) 单步执行
    (3) 执行into指令
    (4) 执行int指令

CPU用中断类型码来标识中断信息的来源, 中断类型码是一个字节型数据, 可以表示256种中断信息的来源, 也称为中断源

中断类型码如下:
    (1) 除法错误: 0
    (2) 单步执行: 1
    (3) 执行into指令: 4
    (4) 执行int指令, 该指令的格式为int n, 指令中的n为字节型立即数, 是提供给CPU的中断类型码

CPU收到中断信息后, 需要对中断信息进行处理, 称为中断处理程序, CPU在收到中断信息后, 会转去执行该中断信息的处理程序, 中断类型
码用于定位中断处理程序, 中断处理程序是一段汇编代码, 有自己的CS:IP地址, CPU利用8位的中断类型码找到中断向量表中存储的中断处理
程序的入口地址

中断向量表存放在内存地址0处, 从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表, 256个中断, 每个中断有CS:IP, 每个
中断占用4个字节, 共1024个字节
```

### 中断执行流程
```
(1) 从中断信息中取得中断类型码
(2) 标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值, 所以先将其保存在栈中)
(3) 设置标志寄存器的第8位TF和第9位IF的值为0
(4) CS的内容入栈
(5) IP的内容入栈
(6) 从内存地址为 IP = 中断类型码 * 4 和 CS = 中断类型码 * 4 + 2  的两个字单元中读取中断处理程序的入口地址设置IP和CS

(7) 执行中断处理程序 

(8) 用iret指令返回
        1、pop IP
        2、pop CS
        3、popf(恢复标志寄存器的值)



单步中断注意点:
    如果TF = 1, 则执行一条指令后, CPU就转去执行1号中断处理程序, 所以TF这个标志寄存器是用来实现单步中断的

响应中断的特殊情况:
    一般情况下, CPU在执行完当前指令后, 如果检测到中断信息, 就响应中断, 引发中断过程, 在有些情况下, CPU在执行完当前指令后, 即便是
    发生中断, 也不会响应, 比如操作ss寄存器后操作sp寄存器, 那么操作完ss寄存器后不会响应中断继续操作sp寄存器, 如下:
        mov ax, 1000h
        mov ss, ax
        mov sp, 0
```

## 第13章_int指令
### int指令
```
格式: int n, n为中断类型码, 功能是引发中断过程

(1) 取中断类型码
(2) 标志寄存器入栈, TF = 0, IF = 0
(3) CS、IP入栈
(4) IP = n * 4, CS = n * 4 + 2
```

### BIOS和DOS所提供的中断例程
```
在系统板的ROM中存放着一套程序, 称为BIOS(基本输入输出系统), 主要包含以下几部分内存:
    (1) 硬件系统的检测和初始化程序
    (2) 外部中断和内部中断的中断例程
    (3) 用于对硬件设备进行I/O操作的中断例程
    (4) 其他和硬件系统相关的中断例程

可以用int指令直接调用BIOS和DOS提供的中断例程来完成某些工作
```

## 第14章_端口
### 端口访问
```
在访问端口的时候, CPU通过端口地址来定位端口, 通过地址总线来传送地址, 数据总线来传送数据, 控制总线来传送读写命令,
端口指令只有in和out, 分别用于从端口读取数据和往端口写入数据

访问内存指令时总线上的信息:
    mov ax, ds:[8]
    (1) CPU通过地址线将地址信息8发出
    (2) CPU通过控制线发出内存读命令, 选中存储器芯片, 并通知它, 将要从中读取数据
    (3) 存储器将8号单元中的数据通过数据线送入CPU

访问端口时总线上的信息: 
    in al, 60h
    (1) CPU通过地址线将地址信息60h发出
    (2) CPU通过控制线发出端口读命令, 选中端口所在的芯片, 并通知它, 将要从中读取数据
    (3) 端口所在的芯片将60h端口中的数据通过数据线送入CPU

访问8位端口时用al, 访问16位端口时用ax, 如果是0-255端口地址的读写, 可以直接指定端口地址, 256-65535端口地址的读写, 需要通过dx等寄存器来传送,
不能直接写数值, 类似于段寄存器的赋值
```

### 移位指令-shl和shr指令
```
shl指令, 逻辑左移指令, 功能为:
    (1) 将一个寄存器或内存单元中的数据向左移位
    (2) 将最后移出的一位写入CF中
    (3) 最低位用0补充

shr指令, 逻辑右移指令, 功能为:
    (1) 将一个寄存器或内存单元中的数据向右位移
    (2) 将最后移出的一位写入CF中
    (3) 最高位用0补充

格式:
    shl al,1
    shr al, 1
    shl al, cl
    shr al, cl
当移动位数大于1的时候, 必须将移动位数放在cl中
```


## 第15章_外中断
### 芯片和端口
```
PC系统的接口卡和主板上, 装有各种接口芯片, 这些外设接口芯片的内部有若干寄存器, CPU将这些寄存器当作端口来访问


外设的输入不直接送入内存和CPU, 而是送入相关的接口芯片的端口中, CPU向外设的输出也不是直接送入外设, 而是先送
入端口中, 再由相关的芯片送到外设, CPU还可以向外设输出控制命令, 而这些控制命令也是先送到相关芯片的端口中, 然
后由相关的芯片跟进命令对外设实施控制

可见, CPU通过端口和外部设备进行联系
```

### 外中断信息
```
当CPU外部有需要处理的事情发生的时候, 比如说, 外设的输入到达, 相关芯片将向CPU发出相应的中断信息, CPU再执行完
当前指令后, 可以检测到发送过来的中断信息, 引发中断过程, 处理外设的输入

外中断源:
    (1) 可屏蔽中断, CPU可以不响应的外中断, CPU是否响应可屏蔽中断, 取决于标志寄存器IF位的设置,
        如果IF=1, 则CPU再执行完当前指令后响应中断, 引发中断过程, 如果IF=0, 则不响应可屏蔽中断

        sti, 设置IF=1
        cli, 设置IF=0

    (2) 不可屏蔽中断, CPU必须响应的外中断, 当CPU检测到不可屏蔽中断信息时, 则在执行完当前指令后, 立即响应, 引发
        中断过程
    
        对于8086CPU来说, 不可屏蔽的中断类型码固定为2, 所以中断过程中, 不需要取中断类型码

几乎所有外设引发的外中断, 都是可屏蔽中断, 不可屏蔽中断是在系统中必须处理的紧急情况发生时用来通知CPU的中断信息
```
